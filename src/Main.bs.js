// Generated by BUCKLESCRIPT VERSION 5.0.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Euclidean$ReactTemplate = require("./Euclidean.bs.js");

function check_duplicate(g, _w) {
  while(true) {
    var w = _w;
    if (w) {
      var match = Euclidean$ReactTemplate.epsilon_identical(g[0], w[0][0]);
      if (match) {
        return true;
      } else {
        _w = w[1];
        continue ;
      }
    } else {
      return false;
    }
  };
}

function append_ghost(g, w) {
  return /* :: */[
          g,
          w
        ];
}

function ghosts_within(_$staropt$star, pt, r, _w) {
  while(true) {
    var w = _w;
    var $staropt$star = _$staropt$star;
    var qualified = $staropt$star !== undefined ? $staropt$star : /* [] */0;
    if (w) {
      var g = w[0];
      var remaining = w[1];
      var match = Euclidean$ReactTemplate.nearest_point_on_primitive(pt, g[0]);
      _w = remaining;
      if (match[0] <= r) {
        _$staropt$star = /* :: */[
          /* tuple */[
            match[1],
            g
          ],
          qualified
        ];
        continue ;
      } else {
        _$staropt$star = qualified;
        continue ;
      }
    } else {
      return qualified;
    }
  };
}

function list_intersections(ghosts) {
  if (ghosts) {
    var k = ghosts[1];
    var g = ghosts[0];
    var f = function (param) {
      var param$1 = g;
      var param$2 = param;
      return Euclidean$ReactTemplate.find_intersections(param$1[0], param$2[0]);
    };
    return Pervasives.$at(List.flatten(List.map(f, k)), list_intersections(k));
  } else {
    return /* [] */0;
  }
}

function epsilon_counter_increment(p, counter) {
  if (counter) {
    var k = counter[1];
    var match = counter[0];
    var c = match[1];
    var p2 = match[0];
    var match$1 = Euclidean$ReactTemplate.epsilon_identical(/* Point */Block.__(2, [p]), /* Point */Block.__(2, [p2]));
    if (match$1) {
      return /* :: */[
              /* tuple */[
                p2,
                c + 1 | 0
              ],
              k
            ];
    } else {
      return /* :: */[
              /* tuple */[
                p2,
                c
              ],
              epsilon_counter_increment(p, k)
            ];
    }
  } else {
    return /* :: */[
            /* tuple */[
              p,
              1
            ],
            /* [] */0
          ];
  }
}

function count_intersection_repeats(_$staropt$star, _intersections) {
  while(true) {
    var intersections = _intersections;
    var $staropt$star = _$staropt$star;
    var counter = $staropt$star !== undefined ? $staropt$star : /* [] */0;
    if (intersections) {
      var counter$prime = epsilon_counter_increment(intersections[0], counter);
      _intersections = intersections[1];
      _$staropt$star = counter$prime;
      continue ;
    } else {
      return counter;
    }
  };
}

function find_biggest_intersections(_$staropt$star, _counted) {
  while(true) {
    var counted = _counted;
    var $staropt$star = _$staropt$star;
    var candidates = $staropt$star !== undefined ? $staropt$star : /* [] */0;
    if (counted) {
      var match = counted[0];
      var c = match[1];
      var pt = match[0];
      if (candidates) {
        var k = candidates[1];
        var c2 = candidates[0][1];
        var match$1 = c === c2;
        if (match$1) {
          var candidates$prime_000 = /* tuple */[
            pt,
            c
          ];
          var candidates$prime = /* :: */[
            candidates$prime_000,
            candidates
          ];
          _counted = k;
          _$staropt$star = candidates$prime;
          continue ;
        } else {
          var match$2 = c > c2;
          if (match$2) {
            var candidates$prime_000$1 = /* tuple */[
              pt,
              c
            ];
            var candidates$prime$1 = /* :: */[
              candidates$prime_000$1,
              /* [] */0
            ];
            _counted = k;
            _$staropt$star = candidates$prime$1;
            continue ;
          } else {
            _counted = k;
            _$staropt$star = candidates;
            continue ;
          }
        }
      } else {
        var candidates$prime_000$2 = /* tuple */[
          pt,
          c
        ];
        var candidates$prime$2 = /* :: */[
          candidates$prime_000$2,
          /* [] */0
        ];
        _counted = counted[1];
        _$staropt$star = candidates$prime$2;
        continue ;
      }
    } else {
      return List.split(candidates)[0];
    }
  };
}

function find_nearest_point(_nearest, pt, _pts) {
  while(true) {
    var pts = _pts;
    var nearest = _nearest;
    if (pts) {
      var k = pts[1];
      var pt2 = pts[0];
      var d2 = Euclidean$ReactTemplate.distance(pt, pt2);
      var candidate = /* tuple */[
        d2,
        pt2
      ];
      if (nearest !== undefined) {
        var nearest$prime = Caml_obj.caml_max(candidate, nearest);
        _pts = k;
        _nearest = nearest$prime;
        continue ;
      } else {
        _pts = k;
        _nearest = candidate;
        continue ;
      }
    } else if (nearest !== undefined) {
      return nearest[1];
    } else {
      return undefined;
    }
  };
}

function snap_cursor(pt, r, w) {
  var match = List.split(ghosts_within(undefined, pt, r, w));
  var intersections = list_intersections(match[1]);
  if (intersections) {
    var counted = count_intersection_repeats(undefined, intersections);
    var biggest = find_biggest_intersections(undefined, counted);
    var best = find_nearest_point(undefined, pt, biggest);
    if (best !== undefined) {
      return best;
    } else {
      return Pervasives.failwith("something is wrong with snap_cursor");
    }
  } else {
    var match$1 = find_nearest_point(undefined, pt, match[0]);
    if (match$1 !== undefined) {
      return match$1;
    } else {
      return pt;
    }
  }
}

exports.append_ghost = append_ghost;
exports.check_duplicate = check_duplicate;
exports.snap_cursor = snap_cursor;
/* No side effect */
