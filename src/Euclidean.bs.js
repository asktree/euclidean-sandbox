// Generated by BUCKLESCRIPT VERSION 5.0.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function sqr(a) {
  return a * a;
}

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

function magnitude(a) {
  return Math.sqrt(dot(a, a));
}

function perpify(a) {
  return /* tuple */[
          -a[1],
          a[0]
        ];
}

function $plus$caret(a, b) {
  return /* tuple */[
          a[0] + b[0],
          a[1] + b[1]
        ];
}

function $neg$caret(a, b) {
  return /* tuple */[
          a[0] - b[0],
          a[1] - b[1]
        ];
}

function $star$caret(a, b) {
  return /* tuple */[
          a * b[0],
          a * b[1]
        ];
}

function $slash$caret(b, a) {
  return /* tuple */[
          b[0] / a,
          b[1] / a
        ];
}

function det(a, b, c, d) {
  return a * d - b * c;
}

function project(v, onto) {
  return $star$caret(dot(v, onto) / dot(onto, onto), onto);
}

function distance(p1, p2) {
  var a = $neg$caret(p1, p2);
  return Math.sqrt(dot(a, a));
}

var epsilon_identical = Caml_obj.caml_equal;

function circle_circle_intersections(c1, c2) {
  var r2 = c2[1];
  var center2 = c2[0];
  var r1 = c1[1];
  var center1 = c1[0];
  var a = $neg$caret(center2, center1);
  var centerDistance = Math.sqrt(dot(a, a));
  if (centerDistance > r1 + r2) {
    return /* [] */0;
  } else if (centerDistance === r1 + r2) {
    return /* :: */[
            $plus$caret($slash$caret($star$caret(r1, $neg$caret(center2, center1)), centerDistance), center1),
            /* [] */0
          ];
  } else {
    var para = (centerDistance * centerDistance - r2 * r2 + r1 * r1) / (2.0 * centerDistance);
    var a$1 = centerDistance * centerDistance - r2 * r2 + r1 * r1;
    var perp = Math.sqrt(4.0 * (centerDistance * centerDistance) * (r1 * r1) - a$1 * a$1) / (2.0 * centerDistance);
    var paraVec = $slash$caret($neg$caret(center2, center1), centerDistance);
    var perpVec = perpify(paraVec);
    return /* :: */[
            $plus$caret($plus$caret($star$caret(para, paraVec), $star$caret(perp, perpVec)), center1),
            /* :: */[
              $neg$caret($plus$caret($star$caret(para, paraVec), center1), $star$caret(perp, perpVec)),
              /* [] */0
            ]
          ];
  }
}

function circle_line_intersections(c, l) {
  var radius = c[1];
  var center = $neg$caret(c[0], l[0]);
  var s = $neg$caret(l[1], l[0]);
  var paraVec = $neg$caret(project(center, s), center);
  var para = Math.sqrt(dot(paraVec, paraVec));
  if (para > 0.01) {
    if (radius * radius > para * para) {
      var perp = Math.sqrt(radius * radius - para * para);
      var perpVec = $slash$caret(perpify(paraVec), para);
      return /* :: */[
              $plus$caret($plus$caret($plus$caret(paraVec, $star$caret(perp, perpVec)), l[0]), center),
              /* :: */[
                $plus$caret($plus$caret($neg$caret(paraVec, $star$caret(perp, perpVec)), l[0]), center),
                /* [] */0
              ]
            ];
    } else if (radius * radius === para * para) {
      return /* :: */[
              $plus$caret($plus$caret(paraVec, l[0]), center),
              /* [] */0
            ];
    } else {
      return /* [] */0;
    }
  } else {
    var out = $slash$caret(s, Math.sqrt(dot(s, s)));
    return /* :: */[
            $plus$caret($plus$caret(l[0], center), $star$caret(radius, out)),
            /* :: */[
              $neg$caret($plus$caret(l[0], center), $star$caret(radius, out)),
              /* [] */0
            ]
          ];
  }
}

function circle_point_intersections(c, p) {
  var diff = $neg$caret(p, c[0]);
  var a = Math.sqrt(dot(diff, diff)) - c[1];
  if (a * a > 0.01 * 0.01) {
    return /* [] */0;
  } else {
    return /* :: */[
            p,
            /* [] */0
          ];
  }
}

function line_line_intersections(l1, l2) {
  var match = l2[1];
  var y4 = match[1];
  var x4 = match[0];
  var match$1 = l2[0];
  var y3 = match$1[1];
  var x3 = match$1[0];
  var match$2 = l1[1];
  var y2 = match$2[1];
  var x2 = match$2[0];
  var match$3 = l1[0];
  var y1 = match$3[1];
  var x1 = match$3[0];
  var x_num = det(det(x1, y1, x2, y2), det(x1, 1.0, x2, 1.0), det(x3, y3, x4, y4), det(x3, 1.0, x4, 1.0));
  var x_den = det(det(x1, 1.0, x2, 1.0), det(y1, 1.0, y2, 1.0), det(x3, 1.0, x4, 1.0), det(y3, 1.0, y4, 1.0));
  var y_num = det(det(x1, y1, x2, y2), det(y1, 1.0, y2, 1.0), det(x3, y3, x4, y4), det(y3, 1.0, y4, 1.0));
  var y_den = det(det(x1, 1.0, x2, 1.0), det(y1, 1.0, y2, 1.0), det(x3, 1.0, x4, 1.0), det(y3, 1.0, y4, 1.0));
  if (Math.abs(y_den) < 0.01 || Math.abs(x_den) < 0.01) {
    return /* [] */0;
  } else {
    return /* :: */[
            /* tuple */[
              x_num / x_den,
              y_num / y_den
            ],
            /* [] */0
          ];
  }
}

function line_point_intersections(l, p) {
  var v = $neg$caret(l[1], l[0]);
  var p$1 = $neg$caret(p, l[0]);
  var proj = project(v, p$1);
  var a = $neg$caret(v, proj);
  if (Math.sqrt(dot(a, a)) > 0.01) {
    return /* [] */0;
  } else {
    return /* :: */[
            $plus$caret(p$1, l[0]),
            /* [] */0
          ];
  }
}

function find_intersections(pr1, pr2) {
  switch (pr1.tag | 0) {
    case 0 : 
        var l1 = pr1[0];
        switch (pr2.tag | 0) {
          case 0 : 
              return line_line_intersections(l1, pr2[0]);
          case 1 : 
              return circle_line_intersections(pr2[0], l1);
          case 2 : 
              return line_point_intersections(l1, pr2[0]);
          
        }
    case 1 : 
        var c1 = pr1[0];
        switch (pr2.tag | 0) {
          case 0 : 
              return circle_line_intersections(c1, pr2[0]);
          case 1 : 
              return circle_circle_intersections(c1, pr2[0]);
          case 2 : 
              return circle_point_intersections(c1, pr2[0]);
          
        }
    case 2 : 
        var p1 = pr1[0];
        switch (pr2.tag | 0) {
          case 0 : 
              return line_point_intersections(pr2[0], p1);
          case 1 : 
              return circle_point_intersections(pr2[0], p1);
          case 2 : 
              var p2 = pr2[0];
              var match = Caml_obj.caml_equal(/* Point */Block.__(2, [p1]), /* Point */Block.__(2, [p2]));
              if (match) {
                return /* :: */[
                        p2,
                        /* [] */0
                      ];
              } else {
                return /* [] */0;
              }
          
        }
    
  }
}

function nearest_point_on_circle(pt, c) {
  var vec = $neg$caret(pt, c[0]);
  var vec$1 = $slash$caret($star$caret(c[1], vec), Math.sqrt(dot(vec, vec)));
  var cpt = $plus$caret(vec$1, c[0]);
  var a = $neg$caret(pt, cpt);
  var dst = Math.sqrt(dot(a, a));
  return /* tuple */[
          dst,
          cpt
        ];
}

function nearest_point_on_line(pt, l) {
  var vec = $neg$caret(l[1], l[0]);
  var pvec = $neg$caret(pt, l[0]);
  var proj = $star$caret(dot(pvec, vec) / dot(vec, vec), vec);
  var npt = $plus$caret(proj, l[0]);
  var a = $neg$caret(pt, npt);
  var dst = Math.sqrt(dot(a, a));
  return /* tuple */[
          dst,
          npt
        ];
}

function nearest_point_on_primitive(pt, pr) {
  switch (pr.tag | 0) {
    case 0 : 
        return nearest_point_on_line(pt, pr[0]);
    case 1 : 
        return nearest_point_on_circle(pt, pr[0]);
    case 2 : 
        var p = pr[0];
        var a = $neg$caret(pt, p);
        return /* tuple */[
                Math.sqrt(dot(a, a)),
                p
              ];
    
  }
}

var epsilon = 0.01;

exports.epsilon = epsilon;
exports.sqr = sqr;
exports.dot = dot;
exports.magnitude = magnitude;
exports.perpify = perpify;
exports.$plus$caret = $plus$caret;
exports.$neg$caret = $neg$caret;
exports.$star$caret = $star$caret;
exports.$slash$caret = $slash$caret;
exports.det = det;
exports.project = project;
exports.distance = distance;
exports.epsilon_identical = epsilon_identical;
exports.circle_circle_intersections = circle_circle_intersections;
exports.circle_line_intersections = circle_line_intersections;
exports.circle_point_intersections = circle_point_intersections;
exports.line_line_intersections = line_line_intersections;
exports.line_point_intersections = line_point_intersections;
exports.find_intersections = find_intersections;
exports.nearest_point_on_circle = nearest_point_on_circle;
exports.nearest_point_on_line = nearest_point_on_line;
exports.nearest_point_on_primitive = nearest_point_on_primitive;
/* No side effect */
